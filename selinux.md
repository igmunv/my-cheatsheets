# SELinux

## Установка и запуск
`apt install selinux-basics selinux-policy-default auditd`

У SELinux 3 режима:
- Enforcing - запрет доступа на основании правил политики
- Permissive - ведение лога действий, нарушающих политику, которые в режиме enforcing были бы запрещены
- Disabled - полное отключение

`getenforce` - посмотреть текущий режим

`setenforce [Enforcing или Permissive]` - устновить режим

Отключить SELinux можно только через файл:
`nano /etc/selinux/config` 
`SELINUX=disabled`

Для начала изменим конфигурацию grub, для запуска selinux:

Редактируем файл `/etc/default/grub`:

в строку

`GRUB_CMDLINE_LINUX_DEFAULT="quiet"`

нужно добавить

`GRUB_CMDLINE_LINUX_DEFAULT="quiet selinux=1 security=selinux"`

и обновить конфигурацию

`update-grub`

Для того чтобы начать маркировкку, в файле конфигурации нужно поставить режим permissive:

`nano /etc/selinux/config` 

`SELINUX=permissive`

После нужно в корне создать файл '/.autorelabel'

`touch /.autorelabel`

И перезагружаем компьютер:

`reboot`

После завершения маркировки и загрузки системы можно перейти к файлу конфигурации и установить режим enforcing.

> Используется режим permissive для маркировки, поскольку использование режима enforcing может привести к краху системы во время перезагрузки.


## Работа с SELinux

`ls -Z ./file.txt` - посмотреть контекст безопасности файла.

`unconfined_u:object_r:user_tmp_t:s0` - пример вывода контекста безопасности

Контекст состоит из четырех частей (разберём на примере выше):
1. `unconfined_u` - SELinux user. Это не системный ппользователь, а пользователь SELinux
2. `object_r` - роль. Для обычных файлов всегда object_r, для процессов другие, например system_r
3. `user_tmp_t` - тип. Это самая важная часть. Это то что определяет саму политику доступа. user_tmp_t говорит, что это файл из /tmp доступный любому пользователю, но, к примеру, веб-сервер не сможет его прочитать
4. `s0` - уровень безопасности. В простых системах почти всегда 0. К примеру модель "секретно" - "совершенно секретно" - "сверхсекретно".


> Когда включён SELinux Добавляется вторая проверка:
> 1. Сначала смотрят обычные Unix-права.
> 2. Потом SELinux решает: «А процесс с типом httpd_t вообще может лезть к объекту с типом user_home_t?»


SELinux хранит правила в таком виде:
`allow httpd_t httpd_sys_content_t:file { read getattr open };`
Перевод:
`процессам с типом httpd_t разрешено читать файлы с типом httpd_sys_content`

Как выглядит правило:

> Субъект - процесс (тот, кто запрашивает).
>
> Объект - директория, файл, сокет (то, что запрашивают).

`<действие> <тип субъекта> <тип объекта>:<класс объекта> { <разрешения> };`

1. Действие - `allow / deny / auditallow` - разрешить / запретить / логировать
   
2. Тип субъекта -обычно процесс (тот, кто запрашивает)
   
3. Тип объекта - файл, директория, сокет, порт (то, что запрашивают)
   
4. Класс объекта - file, dir, socket, process, port
   
5. Разрешения - набор операций, которые разрешаются (read, write)
    

Примеры:

1. Тип субъекта:
   
   `httpd_t` - процесс веб-сервер Apache
   
   `sshd_t` - процесс sshd
   
   `unconfined_t` - свободный процесс пользователя
   
2. Тип объекта:
   
   `httpd_sys_content_t` - файлы веб-контента, для веб-сервера
   
   `user_home_t` - домашние директории пользователей
   
   `var_log_t` - системные логи
   
3. Класс объекта:
   
   `file` - обычный файл
   
   `dir` - директория
   
   `lnk_file` - симлинк
   
   `tcp_socket` - TCP-сокет
   
   `process` - процесс

4. Разрешения

   - Файлы
     
   `read` - чтение содержимого

   `write` - изменение содержимого
   
   `append` - дописывать к содержимому в конец
   
   `create` - создать файл
   
   `unlink` - удалить
   
   `getattr` - читать метаданные (размер, время и т.д)
   
   `open` - открывать файл (без read и write всё равно ничего не сделать)

   
   - Директории
     
   `search` - cd внутрь (зайти в каталог)
   
   `add_name` - создавать новые файлы или директории в каталоге
   
   `remove_name` - удалять файлы или директории
   
   `write` - изменять содержимое каталога (вместе с add и remove)
   
   `getattr` - метаданные каталога

   
   - Сокеты
     
   `name_connect` - подключиться к TCP-порту
   
   `listen` - слушать порт

   `accept` - принимать соединения



Примеры правил:

`allow httpd_t httpd_sys_content_t:file { read getattr open }`

разрешить субъекту с типом httpd_t (apache) действия над объектом с типом httpd_sys_content_t и с классом file, а именно читать, открывать и читать метаданные

> разрешить Apache читать файлы и их метаданные с типом httpd_sys_content_t


`allow httpd_t httpd_sys_content_t:dir { add_name write }`

разрешить субъекту с типом httpd_t (apache) действия над объектом с типом httpd_sys_content_t и с классом dir, а именно добавлять файлы/директории

> разрешить Apache добавлять файлы/директории в директории с типом httpd_sys_content_t


`allow httpd_t port_t:tcp_socket name_connect`

разрешить субъекту с типом httpd_t (apache) действия над объектом с типом port_t и с классом tcp_socket, а именно подключаться к порту

> разрешить Apache подключаться к сети


> SELinux мыслит следующим образом:
> "Процесс с типом X может/не может делать действие Y над объектом с типом Z".

